@page "/"
@implements IDisposable
@inject ISnackbar Snackbar
@inject IOrchestrationService OrchestrationService
@inject IConversationService ConversationService
@inject InsightService InsightService

<MudStack Justify="Justify.SpaceBetween" Class="mx-2 full-height-container">
    @* Header Section *@
    <MudStack Row Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Class="mt-4 flex-shrink-0">
        <MudStack Row Justify="Justify.Center" AlignItems="AlignItems.Center">
            <MudIcon Icon="@(OrchestrationService.IsDeviceConnected? Icons.Material.Filled.BluetoothConnected : Icons.Material.Filled.Bluetooth)"
                     Color="@(OrchestrationService.IsDeviceConnected ? Color.Success : Color.Error)" />
            <MudText Typo="Typo.body1" Color="@(OrchestrationService.IsDeviceConnected? Color.Success: Color.Error)">@(OrchestrationService.IsDeviceConnected ? "Connected" : "Disconnected")</MudText>
        </MudStack>
        @if (OrchestrationService.IsRecording)
        {
            <MudStack Row Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Class="mr-3">
                <span class="recording-indicator"></span>
                <MudText Typo="Typo.body1" Color="Color.Error">Recording</MudText>
            </MudStack>
        }
    </MudStack>

    @* Conversation Container *@
    <div class="conversation-wrapper">
        <ConversationContainer Conversation="@OrchestrationService.CurrentConversation" />
    </div>

    @* Footer Section *@
    <MudStack Justify="Justify.SpaceEvenly" Row
              AlignItems="AlignItems.Center"
              Style="max-width: 400px; width: 100%; margin: 0 auto;"
              Class="pa-4 flex-shrink-0">
        <MudButton @onclick="ToggleRecording"
                   Disabled="@OrchestrationService.IsStateChanging" Variant="Variant.Filled"
                   StartIcon="@(OrchestrationService.IsRecording ? Icons.Material.Filled.Stop : Icons.Material.Filled.Mic)"
                   Color="@(OrchestrationService.IsRecording ? Color.Error : Color.Primary)"
                   Class="rounded-xl py-3"
                   FullWidth>
            @if (OrchestrationService.IsStateChanging)
            {
                <MudProgressCircular Class="ms-n1" Size="Size.Small" Indeterminate="true" />
                <MudText Class="ms-2">Processing</MudText>
            }
            else
            {
                <MudText>@(OrchestrationService.IsRecording ? "Stop" : "Start") Recording</MudText>
            }
        </MudButton>
        <MudButton @onclick="GenerateInsightAsync"
                   Disabled="@isGeneratingInsight" Variant="Variant.Filled"
                   StartIcon="@Icons.Material.Filled.AutoAwesome"
                   Color="@Color.Secondary"
                   Class="rounded-xl py-3" FullWidth>
            @if (isGeneratingInsight)
            {
                <MudProgressCircular Class="ms-n1" Size="Size.Small" Indeterminate="true" />
                <MudText Class="ms-2">Generating</MudText>
            }
            else
            {
                <MudText>Generate Insight</MudText>
            }
        </MudButton>
    </MudStack>
</MudStack>


@code {
    #region Fields
    private bool isGeneratingInsight;
    #endregion

    #region Lifecycle Methods
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Snackbar.Configuration.PositionClass = Defaults.Classes.Position.BottomCenter;

        // Subscribe to state changes from the orchestration service.
        OrchestrationService.ConversationCompleted += OnConversationCompletionAsync;
        OrchestrationService.StateHasChanged += OnStateHasChanged;
        OrchestrationService.Notify += OnNotify;
    }

    private async Task ToggleRecording()
    {
        if (OrchestrationService.IsRecording)
        {
            await OrchestrationService.StopAsync();
        }
        else
        {
            await OrchestrationService.StartAsync();
        }
    }
    #endregion

    #region Event Handlers
    private void OnStateHasChanged(object? sender, EventArgs e)
    {
        // The UI needs to be re-rendered when the state changes.
        InvokeAsync(StateHasChanged);
    }

    private void OnNotify(object? sender, (string message, Severity severity) args)
    {
        Snackbar.Add(args.message, args.severity);
    }

    private async void OnConversationCompletionAsync(object? sender, EventArgs e)
    {
        try
        {
            await GenerateInsightAsync();
            await SaveConversationAsync();
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to save conversation: {ex.Message}", Severity.Error);
        }
        finally
        {
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task SaveConversationAsync()
    {
        try
        {
            await ConversationService.SaveConversationAsync(OrchestrationService.CurrentConversation);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to save conversation: {ex.Message}", Severity.Error);
        }
    }

    private async Task GenerateInsightAsync()
    {
        try
        {
            isGeneratingInsight = true;
            await InvokeAsync(StateHasChanged);

            var conversation = OrchestrationService.CurrentConversation;

            if (conversation.Transcript.Count > 1)
            {
                conversation.DurationMinutes = (conversation.Transcript[^1].Timestamp - conversation.Transcript[0].Timestamp).TotalMinutes;
            }

            var input = new InsightInput()
            {
                Transcript = conversation.Transcript,
                Location = conversation.Location,
                CreatedAt = conversation.CreatedAt,
                DurationMinutes = conversation.DurationMinutes
            };

            var result = await InsightService.GetInsightAsync(input);
            conversation.AiInsights!.ActionItems = result.ActionItems;
            conversation.AiInsights.Topics = result.Topics;
            conversation.Summary = result.Summary;
            conversation.Title = result.Title;
            conversation.Timeline = result.Timeline;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to generate insight: {ex.Message}", Severity.Error);
        }
        finally
        {
            isGeneratingInsight = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    #endregion

    #region Disposal
    public void Dispose()
    {
        OrchestrationService.StateHasChanged -= OnStateHasChanged;
        OrchestrationService.Notify -= OnNotify;
        OrchestrationService.ConversationCompleted -= OnConversationCompletionAsync;
    }
    #endregion
}